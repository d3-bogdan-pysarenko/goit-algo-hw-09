# goit-algo-hw-09

## Вихідні данні:

Для виконання цього практичного завдання було створено 2 функції, які обраховують якими монетами видати здачу покупцеві:
- **Функція жадібного алгоритму** `find_coins_greedy`. Ця функція приймає суму, яку потрібно видати покупцеві, і повертає словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. 
Наприклад, для суми `113` це буде словник `{50: 2, 10: 1, 2: 1, 1: 1}`. Алгоритм є жадібним, тобто спочатку вибирає найбільш доступні номінали монет.

- **Функція динамічного програмування** `find_min_coins`. Ця функція приймає суму для видачі решти, але використовує метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повертає словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми `113` це буде словник `{1: 1, 2: 1, 10: 1, 50: 2}`

### Обидві функції були протестовані на 2х наборах монет а саме:

```bash
coins_list_a = [50, 25, 10, 5, 2, 1]
coins_list_b = [10, 6, 1] // абстрактні монети для більш наглядного прикладу
```

### Для певного набору вказувалася специфічна сума, яку потрібно видати а саме:
- `113` для `coins_list_a`
- `12` для `coins_list_b`

### Отриманий результат виконання функцій для вказаних наборів монет:

```bash
Results for Greedy function, set A -> {50: 2, 10: 1, 2: 1, 1: 1}
Results for Dynamic function, set A -> {1: 1, 2: 1, 10: 1, 50: 2}

Results for Greedy function, set B -> {10: 1, 1: 2}
Results for Dynamic function, set B -> {6: 2}
```

## Висновок:

Жадібні алгоритми зазвичай швидші у виконанні та імплементації, але при  цьому вони не дають гарантії нацбільш оптимального результату виконання завдання, що проілюстровано у їх порівнянні для другого набору абстрактних монет.